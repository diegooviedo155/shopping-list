import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { ITEM_STATUS, ItemStatusType } from '@/lib/constants/item-status';
import type { Category, ItemStatus, ShoppingItem } from '@/lib/types/database';
import { ShoppingItem as DomainShoppingItem } from '@/lib/domain/entities/ShoppingItem';
import { ItemName } from '@/lib/domain/value-objects/ItemName';
import { ItemStatus as DomainItemStatus } from '@/lib/domain/value-objects/ItemStatus';
import { Category as DomainCategory } from '@/lib/domain/value-objects/Category';

interface ShoppingStoreState {
  // Estado principal
  items: DomainShoppingItem[]
  loading: boolean
  error: string | null
  lastFetch: number | null
  activeTab: ItemStatus
  selectedCategory: Category
  hasInitialized: boolean
  isRefreshing: boolean

  // Verificar si debe hacer fetch
  shouldFetch: () => boolean

  // Inicializaci√≥n inteligente
  initialize: () => Promise<void>

  // Fetch optimizado con cach√©
  fetchItems: (force?: boolean) => Promise<void>

  // Crear item con actualizaci√≥n optimista
  addItem: (name: string, category: string, status: string) => Promise<void>

  // Actualizar item con actualizaci√≥n optimista
  updateItem: (id: string, updates: Partial<DomainShoppingItem>) => Promise<void>

  // Toggle de completado
  toggleItemCompleted: (id: string) => Promise<void>

  // Mover item entre estados
  moveItemToStatus: (id: string, status: string) => Promise<void>

  // Eliminar item
  deleteItem: (id: string) => Promise<void>

  // Reordenar items
  reorderItems: (ids: string[]) => Promise<void>

  // Cambiar tab activo
  setActiveTab: (tab: ItemStatus) => void

  // Cambiar categor√≠a seleccionada
  setSelectedCategory: (category: Category) => void

  // Limpiar error
  clearError: () => void

  // Refetch manual
  refetch: (force?: boolean) => Promise<void>

  // Getters memoizados
  getItemsByStatus: (status: string) => DomainShoppingItem[]
  getItemsByCategory: (category: string) => DomainShoppingItem[]
  getCompletedCount: () => number
  getTotalCount: () => number

  // Limpiar items inv√°lidos
  cleanInvalidItems: () => DomainShoppingItem[]
  cleanAndUpdateItems: () => void
}

const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos
const API_BASE = '/api/shopping-items';

console.log('Creating unified shopping store...');

export const useUnifiedShoppingStore = create<ShoppingStoreState>()(
  devtools(
    persist(
      (set, get) => {
        console.log('Store creator function called');
        return {
          // Estado inicial
          items: [] as DomainShoppingItem[],
          loading: false,
          error: null,
          lastFetch: null,
          activeTab: ITEM_STATUS.THIS_MONTH as ItemStatus,
          selectedCategory: 'supermercado' as Category,
          hasInitialized: false,
          isRefreshing: false,

          // Verificar si debe hacer fetch
          shouldFetch: () => {
            const state = get();
            const now = Date.now();
            return (
              !state.hasInitialized ||
              !state.lastFetch ||
              (now - state.lastFetch) > CACHE_DURATION ||
              state.items.length === 0
            );
          },

          // Inicializaci√≥n inteligente
          initialize: async () => {
            const state = get();
            console.log('üöÄ INITIALIZE CALLED:', { 
              hasInitialized: state.hasInitialized, 
              shouldFetch: state.shouldFetch(),
              itemsCount: state.items.length,
              lastFetch: state.lastFetch,
              loading: state.loading,
              error: state.error
            });
            
            if (state.hasInitialized && !state.shouldFetch()) {
              console.log('initialize: skipping - already initialized and no need to fetch');
              return;
            }
            
            console.log('initialize: fetching items...');
            try {
              await state.fetchItems(false);
              console.log('‚úÖ initialize: fetchItems completed successfully');
              // Verificar el estado despu√©s del fetch
              const newState = get();
              console.log('üìä State after fetch:', {
                itemsCount: newState.items.length,
                loading: newState.loading,
                error: newState.error,
                hasInitialized: newState.hasInitialized
              });
            } catch (error) {
              console.log('‚ùå initialize: fetchItems failed:', error);
            }
            set({ hasInitialized: true });
            console.log('‚úÖ initialize: completed');
          },

          // Fetch optimizado con cach√©
          fetchItems: async (force = false) => {
            const state = get();
            console.log('fetchItems called:', { 
              force, 
              loading: state.loading, 
              shouldFetch: state.shouldFetch(),
              itemsCount: state.items.length 
            });
            
            // No hacer fetch si ya est√° cargando o si no es necesario
            if (state.loading && !force) {
              console.log('fetchItems: skipping - already loading');
              return;
            }
            if (!force && !state.shouldFetch()) {
              console.log('fetchItems: skipping - should not fetch');
              return;
            }

            console.log('fetchItems: starting fetch...');
            set({ 
              loading: true, 
              error: null,
              isRefreshing: state.items.length > 0 
            });

            try {
              console.log('fetchItems: making API call to:', API_BASE);
              const response = await fetch(API_BASE, {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json',
                },
                // Solo usar cache si no es forzado
                ...(force ? { cache: 'no-store' } : {})
              });

              if (!response.ok) {
                console.log('fetchItems: API error:', response.status, response.statusText);
                throw new Error(`Error ${response.status}: ${response.statusText}`);
              }

              const data = await response.json();
              console.log('fetchItems: API response:', data);
              console.log('fetchItems: API response length:', data.length);
              console.log('fetchItems: API response type:', typeof data);
              console.log('fetchItems: Is array?', Array.isArray(data));
              
              if (!Array.isArray(data)) {
                console.log('fetchItems: Invalid response format - not an array:', data);
                throw new Error('Invalid response format');
              }

              const formattedItems: DomainShoppingItem[] = data.map((item: any) => 
                DomainShoppingItem.fromPersistence({
                  id: String(item.id || ''),
                  name: new ItemName(item.name || 'Sin nombre'),
                  category: new DomainCategory(item.category?.slug || item.categoryId || 'supermercado'),
                  status: new DomainItemStatus(
                    (item.status && Object.values(ITEM_STATUS).includes(item.status as ItemStatusType))
                      ? item.status
                      : ITEM_STATUS.NEXT_MONTH
                  ),
                  completed: Boolean(item.completed),
                  orderIndex: Number(item.orderIndex || item.order_index || 0),
                  createdAt: new Date(item.createdAt || item.created_at || new Date()),
                  updatedAt: new Date(item.updatedAt || item.updated_at || new Date())
                })
              );

              console.log('fetchItems: formatted items:', formattedItems.length, 'items');
              set({ 
                items: formattedItems, 
                loading: false,
                lastFetch: Date.now(),
                isRefreshing: false
              });
              console.log('fetchItems: completed successfully');
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Error desconocido';
              console.log('fetchItems: error occurred:', errorMessage);
              set({ 
                error: errorMessage, 
                loading: false,
                isRefreshing: false
              });
            }
          },

          // Crear item con actualizaci√≥n optimista
          addItem: async (name, category, status) => {
            const trimmedName = name.trim();
            if (!trimmedName) return;

            set({ loading: true, error: null });

            try {
              const response = await fetch(API_BASE, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: trimmedName, categoryId: category, status }),
              });

              if (!response.ok) {
                throw new Error('Error al agregar el producto');
              }

              const newItem = await response.json();
              
              const formattedItem: DomainShoppingItem = DomainShoppingItem.fromPersistence({
                id: String(newItem.id),
                name: new ItemName(newItem.name),
                category: new DomainCategory(newItem.category?.slug || newItem.categoryId),
                status: new DomainItemStatus(newItem.status),
                completed: Boolean(newItem.completed),
                orderIndex: Number(newItem.orderIndex),
                createdAt: new Date(newItem.createdAt),
                updatedAt: new Date(newItem.updatedAt)
              });

              set((state) => ({
                items: [...state.items, formattedItem],
                loading: false,
                lastFetch: Date.now()
              }));
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Error al agregar producto';
              set({ error: errorMessage, loading: false });
            }
          },

          // Actualizar item con actualizaci√≥n optimista
          updateItem: async (id, updates) => {
            const state = get();
            const originalItem = state.items.find(item => item.id === id);
            
            if (!originalItem) return;

            // Actualizaci√≥n optimista inmediata
            set((state) => {
              const newItems = state.items.map(item =>
                item.id === id ? 
                  DomainShoppingItem.create({
                    ...item.toPrimitives(),
                    ...updates
                  }) : item
              );
              return { items: newItems };
            });

            try {
              // Serializar updates para la API
              const serializedUpdates: any = {};
              if (updates.name) {
                serializedUpdates.name = updates.name.getValue ? updates.name.getValue() : updates.name;
              }
              if (updates.status) {
                serializedUpdates.status = updates.status.getValue ? updates.status.getValue() : updates.status;
              }
              if (updates.category) {
                serializedUpdates.categoryId = updates.category.getValue ? updates.category.getValue() : updates.category;
              }
              if (updates.completed !== undefined) {
                serializedUpdates.completed = updates.completed;
              }

              const response = await fetch(`${API_BASE}/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(serializedUpdates),
              });

              if (!response.ok) {
                throw new Error('Error al actualizar el producto');
              }

              const updatedItem = await response.json();
              
              // Actualizar con la respuesta del servidor
              set((state) => {
                const newItems = state.items.map(item =>
                  item.id === id ? 
                    DomainShoppingItem.fromPersistence({
                      id: String(updatedItem.id),
                      name: new ItemName(updatedItem.name),
                      category: new DomainCategory(updatedItem.category?.slug || updatedItem.categoryId),
                      status: new DomainItemStatus(updatedItem.status),
                      completed: Boolean(updatedItem.completed),
                      orderIndex: Number(updatedItem.orderIndex),
                      createdAt: new Date(updatedItem.createdAt),
                      updatedAt: new Date(updatedItem.updatedAt)
                    }) : item
                );
                return { items: newItems };
              });
            } catch (error) {
              // Revertir cambios en caso de error
              set((state) => {
                const newItems = state.items.map(item =>
                  item.id === id ? originalItem : item
                );
                return { items: newItems };
              });
              
              const errorMessage = error instanceof Error ? error.message : 'Error al actualizar producto';
              set({ error: errorMessage });
            }
          },

          // Toggle de completado
          toggleItemCompleted: async (id) => {
            const state = get();
            const item = state.items.find(item => item.id === id);
            if (!item) return;

            const newCompleted = !item.completed;
            await state.updateItem(id, { completed: newCompleted });
          },

          // Mover item entre estados
          moveItemToStatus: async (id, status) => {
            console.log('moveItemToStatus called:', { id, status });
            const state = get();
            const item = state.items.find(item => item.id === id);
            if (!item) return;

            console.log('moveItemToStatus: item found:', item);
            await state.updateItem(id, { status: new DomainItemStatus(status) });
            console.log('moveItemToStatus: completed');
          },

          // Eliminar item
          deleteItem: async (id) => {
            set((state) => ({
              items: state.items.filter(item => item.id !== id)
            }));

            try {
              const response = await fetch(`${API_BASE}/${id}`, {
                method: 'DELETE',
              });

              if (!response.ok) {
                throw new Error('Error al eliminar el producto');
              }
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Error al eliminar producto';
              set({ error: errorMessage });
            }
          },

          // Reordenar items
          reorderItems: async (ids) => {
            set((state) => {
              const newItems = [...state.items];
              ids.forEach((id, index) => {
                const item = newItems.find(item => item.id === id);
                if (item) {
                  newItems[newItems.indexOf(item)] = DomainShoppingItem.create({
                    ...item.toPrimitives(),
                    orderIndex: index
                  });
                }
              });
              return { items: newItems };
            });

            try {
              const response = await fetch(`${API_BASE}/reorder`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ids }),
              });

              if (!response.ok) {
                throw new Error('Error al reordenar productos');
              }
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : 'Error al reordenar productos';
              set({ error: errorMessage });
            }
          },

          // Cambiar tab activo
          setActiveTab: (tab) => {
            set({ activeTab: tab });
          },

          // Cambiar categor√≠a seleccionada
          setSelectedCategory: (category) => {
            set({ selectedCategory: category });
          },

          // Limpiar error
          clearError: () => {
            set({ error: null });
          },

          // Refetch manual
          refetch: async (force = true) => {
            await get().fetchItems(force);
          },

          // Getters memoizados
          getItemsByStatus: (status) => {
            const state = get();
            const validItems = state.cleanInvalidItems();
            return validItems
              .filter(item => {
                if (!item || !item.status || typeof item.status.getValue !== 'function') {
                  return false;
                }
                return item.status.getValue() === status;
              })
              .sort((a, b) => a.orderIndex - b.orderIndex);
          },

          getItemsByCategory: (category) => {
            const state = get();
            const validItems = state.cleanInvalidItems();
            return validItems
              .filter(item => {
                if (!item || !item.category || typeof item.category.getValue !== 'function') {
                  return false;
                }
                return item.category.getValue() === category;
              })
              .sort((a, b) => a.orderIndex - b.orderIndex);
          },

          getCompletedCount: () => {
            const state = get();
            const validItems = state.cleanInvalidItems();
            return validItems.filter(item => {
              if (!item || !item.status || typeof item.status.getValue !== 'function') {
                return false;
              }
              return item.status.getValue() === ITEM_STATUS.THIS_MONTH && item.completed;
            }).length;
          },

          getTotalCount: () => {
            const state = get();
            const validItems = state.cleanInvalidItems();
            return validItems.filter(item => {
              if (!item || !item.status || typeof item.status.getValue !== 'function') {
                return false;
              }
              return item.status.getValue() === ITEM_STATUS.THIS_MONTH;
            }).length;
          },

          // Limpiar items inv√°lidos
          cleanInvalidItems: () => {
            const state = get();
            console.log('cleanInvalidItems - Total items:', state.items.length);
            console.log('cleanInvalidItems - Items:', state.items.map(item => ({
              id: item?.id,
              name: item?.name,
              status: item?.status,
              category: item?.category,
              hasNameGetValue: item?.name && typeof item.name.getValue === 'function',
              hasStatusGetValue: item?.status && typeof item.status.getValue === 'function',
              hasCategoryGetValue: item?.category && typeof item.category.getValue === 'function'
            })));
            
            const validItems = state.items.filter(item => {
              // Filtrar objetos ShoppingItem o con props
              if (item && typeof item === 'object') {
                if (item.props || (item.constructor && item.constructor.name === 'ShoppingItem')) {
                  console.log('Found invalid item (ShoppingItem or props):', item);
                  return false;
                }
                // Verificar que tenga las propiedades necesarias con m√©todos getValue
                if (!item.name || !item.status || !item.category || 
                    typeof item.name.getValue !== 'function' || 
                    typeof item.status.getValue !== 'function' || 
                    typeof item.category.getValue !== 'function') {
                  console.log('Found item without required methods:', item);
                  return false;
                }
              }
              return item && typeof item === 'object';
            });
            
            console.log('cleanInvalidItems - Valid items:', validItems.length);
            return validItems;
          },

          cleanAndUpdateItems: () => {
            const state = get();
            const validItems = state.items.filter(item => {
              // Filtrar objetos ShoppingItem o con props
              if (item && typeof item === 'object') {
                if (item.props || (item.constructor && item.constructor.name === 'ShoppingItem')) {
                  console.log('Removing invalid item:', item);
                  return false;
                }
                // Verificar que tenga las propiedades necesarias con m√©todos getValue
                if (!item.name || !item.status || !item.category || 
                    typeof item.name.getValue !== 'function' || 
                    typeof item.status.getValue !== 'function' || 
                    typeof item.category.getValue !== 'function') {
                  console.log('Removing item without required methods:', item);
                  return false;
                }
              }
              return item && typeof item === 'object';
            });
            
            if (validItems.length !== state.items.length) {
              console.log(`Cleaned ${state.items.length - validItems.length} invalid items`);
              set({ items: validItems });
            }
          }
        };
      },
      {
        name: 'unified-shopping-store',
        partialize: (state) => ({
          // Convertir entidades de dominio a objetos planos para persistencia
          items: state.items.map(item => {
            // Verificar si es una entidad de dominio v√°lida
            if (item && typeof item.toPrimitives === 'function') {
              return item.toPrimitives();
            }
            // Si no es una entidad v√°lida, devolver como est√°
            return item;
          }),
          activeTab: state.activeTab,
          selectedCategory: state.selectedCategory,
          lastFetch: state.lastFetch,
          hasInitialized: state.hasInitialized
        }),
        onRehydrateStorage: () => (state) => {
          if (state) {
            console.log('Rehydrating store...');
            // Convertir objetos planos de vuelta a entidades de dominio
            state.items = state.items
              .map((item: any) => {
                try {
                  // Verificar si es un objeto v√°lido
                  if (item && typeof item === 'object' && item.id && item.name && item.status && item.category) {
                    return DomainShoppingItem.fromPersistence({
                      id: String(item.id),
                      name: new ItemName(item.name),
                      category: new DomainCategory(item.category),
                      status: new DomainItemStatus(item.status),
                      completed: Boolean(item.completed),
                      orderIndex: Number(item.orderIndex || 0),
                      createdAt: new Date(item.createdAt || new Date()),
                      updatedAt: new Date(item.updatedAt || new Date())
                    });
                  }
                  return null;
                } catch (error) {
                  console.log('Error converting item during rehydration:', error, item);
                  return null;
                }
              })
              .filter((item: any) => item !== null); // Filtrar items nulos
          }
        }
      }
  )
);